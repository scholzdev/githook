use tower_lsp::lsp_types::*;
use crate::document::DocumentState;

/// Get completion items at the given position
pub fn get_completions(doc: &DocumentState, position: Position) -> Vec<CompletionItem> {
    let mut completions = Vec::new();
    
    // Check context
    if let Some(context) = get_context(doc, position) {
        match context {
            GithookCompletionContext::MacroCall => {
                // Only suggest macros
                for macro_name in &doc.macros {
                    completions.push(CompletionItem {
                        label: macro_name.clone(),
                        kind: Some(CompletionItemKind::FUNCTION),
                        detail: Some("Macro call".to_string()),
                        insert_text: Some(macro_name.clone()),
                        insert_text_format: Some(InsertTextFormat::PLAIN_TEXT),
                        ..Default::default()
                    });
                }
                return completions;
            }
            GithookCompletionContext::PropertyAccess(prefix) => {
                return get_property_completions(&prefix);
            }
            GithookCompletionContext::Normal => {
                // Fall through to normal completions
            }
        }
    }

    // Keywords
    let keywords = vec![
        ("run", "Execute a shell command", CompletionItemKind::KEYWORD),
        ("block", "Block the commit with a message", CompletionItemKind::KEYWORD),
        ("warn", "Show a warning message", CompletionItemKind::KEYWORD),
        ("allow", "Allow a specific command", CompletionItemKind::KEYWORD),
        ("if", "Conditional execution", CompletionItemKind::KEYWORD),
        ("else", "Alternative branch", CompletionItemKind::KEYWORD),
        ("match", "Pattern matching", CompletionItemKind::KEYWORD),
        ("foreach", "Iterate over collection", CompletionItemKind::KEYWORD),
        ("break", "Exit loop", CompletionItemKind::KEYWORD),
        ("continue", "Skip to next iteration", CompletionItemKind::KEYWORD),
        ("parallel", "Run commands in parallel", CompletionItemKind::KEYWORD),
        ("let", "Define a variable", CompletionItemKind::KEYWORD),
        ("macro", "Define a reusable macro", CompletionItemKind::KEYWORD),
        ("use", "Import from stdlib", CompletionItemKind::KEYWORD),
        ("import", "Import from file", CompletionItemKind::KEYWORD),
        ("try", "Try/catch block", CompletionItemKind::KEYWORD),
        ("catch", "Error handler", CompletionItemKind::KEYWORD),
        ("where", "Filter condition", CompletionItemKind::KEYWORD),
    ];

    for (label, detail, kind) in keywords {
        completions.push(CompletionItem {
            label: label.to_string(),
            kind: Some(kind),
            detail: Some(detail.to_string()),
            insert_text: Some(format!("{} ", label)),
            insert_text_format: Some(InsertTextFormat::PLAIN_TEXT),
            ..Default::default()
        });
    }

    // Global objects
    let globals = vec![
        ("git", "Git context (staged_files, all_files, branch, etc.)"),
        ("true", "Boolean true"),
        ("false", "Boolean false"),
        ("null", "Null value"),
    ];

    for (label, detail) in globals {
        completions.push(CompletionItem {
            label: label.to_string(),
            kind: Some(CompletionItemKind::CONSTANT),
            detail: Some(detail.to_string()),
            ..Default::default()
        });
    }

    // Operators
    let operators = vec![
        ("==", "Equal comparison", "file.size == 0"),
        ("!=", "Not equal comparison", "f.extension != \".md\""),
        (">", "Greater than", "git.stats.additions > 100"),
        (">=", "Greater or equal", "f.size >= 1024"),
        ("<", "Less than", "git.stats.deletions < 10"),
        ("<=", "Less or equal", "f.size <= 100"),
        ("and", "Logical AND", "a > 0 and b < 10"),
        ("or", "Logical OR", "f.extension == \".rs\" or f.extension == \".toml\""),
        ("not", "Logical NOT", "not f.exists()"),
        ("in", "Loop variable", "foreach items { x in ... }"),
    ];

    for (label, detail, example) in operators {
        completions.push(CompletionItem {
            label: label.to_string(),
            kind: Some(CompletionItemKind::OPERATOR),
            detail: Some(detail.to_string()),
            documentation: Some(Documentation::String(format!("Example: {}", example))),
            ..Default::default()
        });
    }

    completions
}

#[derive(Debug, PartialEq)]
enum GithookCompletionContext {
    Normal,
    MacroCall,
    PropertyAccess(String), // Prefix like "file", "git", "f.path", etc.
}

/// Get the current completion context
fn get_context(doc: &DocumentState, position: Position) -> Option<GithookCompletionContext> {
    let line_idx = position.line as usize;
    let lines: Vec<&str> = doc.text.lines().collect();
    
    if line_idx >= lines.len() {
        return Some(GithookCompletionContext::Normal);
    }
    
    let line = lines[line_idx];
    let char_idx = position.character as usize;
    
    if char_idx == 0 || char_idx > line.len() {
        return Some(GithookCompletionContext::Normal);
    }
    
    let before_cursor = &line[..char_idx];
    
    // Check for property access: prefix.
    // Find last dot that's not in a string
    if let Some(dot_pos) = before_cursor.rfind('.') {
        // Get the identifier before the dot
        let before_dot = &before_cursor[..dot_pos];
        
        // Find where the identifier starts (after whitespace, operators, etc.)
        let ident_start = before_dot.rfind(|c: char| {
            c.is_whitespace() || c == '(' || c == '{' || c == '[' || 
            c == ',' || c == '=' || c == '!' || c == '<' || c == '>'
        }).map(|pos| pos + 1).unwrap_or(0);
        
        let prefix = before_dot[ident_start..].trim();
        
        if !prefix.is_empty() {
            return Some(GithookCompletionContext::PropertyAccess(prefix.to_string()));
        }
    }
    
    // Check for macro call: @prefix
    let word_start = before_cursor.rfind(|c: char| c.is_whitespace() || c == '{' || c == '}')
        .map(|pos| pos + 1)
        .unwrap_or(0);
    
    let current_word = &before_cursor[word_start..];
    
    if current_word.starts_with('@') {
        return Some(GithookCompletionContext::MacroCall);
    }
    
    Some(GithookCompletionContext::Normal)
}

/// Get property completions based on object prefix
fn get_property_completions(prefix: &str) -> Vec<CompletionItem> {
    let mut completions = Vec::new();
    
    match prefix {
        "git" => {
            let properties = vec![
                ("staged_files", "Array of staged files", "foreach git.staged_files { f in ... }"),
                ("all_files", "Array of all files in repo", "foreach git.all_files { f in ... }"),
                ("branch", "Branch object (branch.name)", "git.branch.name"),
                ("commit", "Commit object (commit.message, commit.hash)", "git.commit.message"),
                ("author", "Author object (author.name, author.email)", "git.author.name"),
                ("remote", "Remote object (remote.name, remote.url)", "git.remote.url"),
                ("stats", "Stats object (files_changed, additions, deletions)", "git.stats.additions"),
                ("is_merge_commit", "Boolean: is merge commit", "git.is_merge_commit"),
                ("has_conflicts", "Boolean: has conflicts", "git.has_conflicts"),
            ];
            
            for (name, detail, example) in properties {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::PROPERTY),
                    detail: Some(detail.to_string()),
                    documentation: Some(Documentation::String(format!("Example: {}", example))),
                    ..Default::default()
                });
            }
        }
        "git.branch" | "branch" => {
            completions.push(CompletionItem {
                label: "name".to_string(),
                kind: Some(CompletionItemKind::PROPERTY),
                detail: Some("Branch name as string".to_string()),
                ..Default::default()
            });
        }
        "git.commit" | "commit" => {
            let properties = vec![
                ("message", "Commit message"),
                ("hash", "Commit hash"),
            ];
            for (name, detail) in properties {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::PROPERTY),
                    detail: Some(detail.to_string()),
                    ..Default::default()
                });
            }
        }
        "git.author" | "author" => {
            let properties = vec![
                ("name", "Author name"),
                ("email", "Author email"),
            ];
            for (name, detail) in properties {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::PROPERTY),
                    detail: Some(detail.to_string()),
                    ..Default::default()
                });
            }
        }
        "git.remote" | "remote" => {
            let properties = vec![
                ("name", "Remote name (e.g., 'origin')"),
                ("url", "Remote URL"),
            ];
            for (name, detail) in properties {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::PROPERTY),
                    detail: Some(detail.to_string()),
                    ..Default::default()
                });
            }
        }
        "git.stats" | "stats" => {
            let properties = vec![
                ("files_changed", "Number of changed files"),
                ("additions", "Lines added"),
                ("deletions", "Lines deleted"),
                ("modified_lines", "Total modified lines (additions + deletions)"),
            ];
            for (name, detail) in properties {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::PROPERTY),
                    detail: Some(detail.to_string()),
                    ..Default::default()
                });
            }
        }
        prefix if prefix.starts_with("f") || prefix.starts_with("file") => {
            // File object properties and methods
            let properties = vec![
                ("name", "Filename with extension (property)"),
                ("path", "PathContext object with path info (property)"),
                ("basename", "Filename without extension (property)"),
                ("extension", "File extension (property)"),
                ("dirname", "Directory path (property)"),
                ("size", "File size in bytes (property)"),
            ];
            let methods = vec![
                ("exists()", "Check if file exists (method)"),
                ("contains(pattern)", "Check if file contains pattern (method)"),
                ("starts_with(prefix)", "Check if file path starts with (method)"),
                ("ends_with(suffix)", "Check if file path ends with (method)"),
            ];
            
            for (name, detail) in properties {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::PROPERTY),
                    detail: Some(detail.to_string()),
                    ..Default::default()
                });
            }
            for (name, detail) in methods {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::METHOD),
                    detail: Some(detail.to_string()),
                    ..Default::default()
                });
            }
        }
        prefix if prefix.ends_with(".path") || prefix == "path" => {
            // PathContext properties and methods
            let properties = vec![
                ("string", "Full path as string (property)"),
                ("basename", "Filename without extension (property)"),
                ("extension", "File extension with dot (property)"),
                ("parent", "Parent directory path (property)"),
                ("filename", "Filename with extension (property)"),
            ];
            let methods = vec![
                ("join(suffix)", "Join path with suffix (method)"),
            ];
            
            for (name, detail) in properties {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::PROPERTY),
                    detail: Some(detail.to_string()),
                    ..Default::default()
                });
            }
            for (name, detail) in methods {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::METHOD),
                    detail: Some(detail.to_string()),
                    ..Default::default()
                });
            }
        }
        _ => {
            // Unknown prefix - no suggestions
        }
    }
    
    completions
}

            ..Default::default()
        });
    }

    // Operators
    let operators = vec![
        ("matches", "Regex match operator", "content matches \"^TODO\""),
        ("contains", "String contains operator", "content contains \"panic!\""),
        ("==", "Equality operator", "file_size == 0"),
        ("!=", "Not equals operator", "branch_name != \"main\""),
        (">", "Greater than operator", "file_size > 1000000"),
        (">=", "Greater or equal operator", "modified_lines >= 500"),
        ("<", "Less than operator", "additions < 10"),
        ("<=", "Less or equal operator", "deletions <= 100"),
        ("and", "Logical AND", "file_size > 0 and content matches \"test\""),
        ("or", "Logical OR", "extension == \".rs\" or extension == \".toml\""),
        ("not", "Logical NOT / negation", "not author_set"),
        ("in", "List membership", "extension in {forbidden}"),
        ("matching", "Pattern for foreach", "foreach file in staged_files matching \"*.rs\""),
    ];

    for (label, detail, example) in operators {
        completions.push(CompletionItem {
            label: label.to_string(),
            kind: Some(CompletionItemKind::OPERATOR),
            detail: Some(detail.to_string()),
            documentation: Some(Documentation::String(format!("Example: {}", example))),
            ..Default::default()
        });
    }

    completions
}

#[derive(Debug, PartialEq)]
enum GithookCompletionContext {
    Normal,
    MacroCall,
    Placeholder(String), // Prefix like "file", "git", "env", etc.
}

/// Get the current completion context
fn get_context(doc: &DocumentState, position: Position) -> Option<GithookCompletionContext> {
    let line_idx = position.line as usize;
    let lines: Vec<&str> = doc.text.lines().collect();
    
    if line_idx >= lines.len() {
        return Some(GithookCompletionContext::Normal);
    }
    
    let line = lines[line_idx];
    let char_idx = position.character as usize;
    
    if char_idx == 0 || char_idx > line.len() {
        return Some(GithookCompletionContext::Normal);
    }
    
    let before_cursor = &line[..char_idx];
    
    // Check for placeholder: {prefix: or {prefix
    if let Some(brace_pos) = before_cursor.rfind('{') {
        let after_brace = &before_cursor[brace_pos + 1..];
        
        // No closing brace yet?
        if !after_brace.contains('}') {
            // Check if we have a colon
            if let Some(colon_pos) = after_brace.find(':') {
                let prefix = after_brace[..colon_pos].trim();
                return Some(GithookCompletionContext::Placeholder(prefix.to_string()));
            } else {
                // Just "{prefix" - suggest namespace
                return Some(GithookCompletionContext::Placeholder(after_brace.trim().to_string()));
            }
        }
    }
    
    // Check for macro call: @prefix
    let word_start = before_cursor.rfind(|c: char| c.is_whitespace() || c == '{' || c == '}')
        .map(|pos| pos + 1)
        .unwrap_or(0);
    
    let current_word = &before_cursor[word_start..];
    
    if current_word.starts_with('@') {
        return Some(GithookCompletionContext::MacroCall);
    }
    
    Some(GithookCompletionContext::Normal)
}

/// Get placeholder completions based on prefix
fn get_placeholder_completions(prefix: &str) -> Vec<CompletionItem> {
    let mut completions = Vec::new();
    
    match prefix {
        "" => {
            // No prefix yet - suggest all namespaces
            let namespaces = vec![
                ("file", "File context placeholders"),
                ("git", "Git context placeholders"),
                ("commit", "Commit context placeholders"),
                ("repo", "Repository context placeholders"),
                ("system", "System context placeholders"),
                ("diff", "Diff context placeholders"),
                ("time", "Time context placeholders"),
                ("env", "Environment variables"),
            ];
            
            for (ns, detail) in namespaces {
                completions.push(CompletionItem {
                    label: format!("{}:", ns),
                    kind: Some(CompletionItemKind::MODULE),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}:", ns)),
                    ..Default::default()
                });
            }
        }
        "file" => {
            let placeholders = vec![
                ("path", "Complete file path"),
                ("name", "Filename with extension"),
                ("basename", "Filename without extension"),
                ("extension", "File extension"),
                ("dirname", "Directory path"),
                ("size", "File size in bytes"),
            ];
            
            for (name, detail) in placeholders {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::FIELD),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}}}",name)),
                    ..Default::default()
                });
            }
        }
        "git" => {
            let placeholders = vec![
                ("branch", "Current branch name"),
                ("commit_message", "Commit message"),
                ("author_name", "Author name"),
                ("author_email", "Author email"),
                ("repo_root", "Repository root path"),
                ("remote_url", "Remote URL"),
            ];
            
            for (name, detail) in placeholders {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::FIELD),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}}}",name)),
                    ..Default::default()
                });
            }
        }
        "commit" => {
            let placeholders = vec![
                ("message", "Commit message"),
                ("files", "Number of changed files"),
                ("additions", "Added lines"),
                ("deletions", "Deleted lines"),
            ];
            
            for (name, detail) in placeholders {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::FIELD),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}}}",name)),
                    ..Default::default()
                });
            }
        }
        "diff" => {
            let placeholders = vec![
                ("added", "Added lines (only + lines)"),
                ("stats", "Diff statistics"),
            ];
            
            for (name, detail) in placeholders {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::FIELD),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}}}",name)),
                    ..Default::default()
                });
            }
        }
        "repo" => {
            let placeholders = vec![
                ("root", "Repository root path"),
                ("name", "Repository name"),
                ("has_remote", "Has remote (true/false)"),
            ];
            
            for (name, detail) in placeholders {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::FIELD),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}}}",name)),
                    ..Default::default()
                });
            }
        }
        "system" => {
            let placeholders = vec![
                ("os", "Operating system"),
                ("arch", "Architecture"),
                ("user", "Username"),
                ("hostname", "Machine hostname"),
            ];
            
            for (name, detail) in placeholders {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::FIELD),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}}}",name)),
                    ..Default::default()
                });
            }
        }
        "time" => {
            let placeholders = vec![
                ("hour", "Current hour (0-23)"),
                ("day", "Day of week"),
                ("is_weekend", "Is weekend (true/false)"),
                ("is_night", "Is night time (true/false)"),
            ];
            
            for (name, detail) in placeholders {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::FIELD),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}}}",name)),
                    ..Default::default()
                });
            }
        }
        "env" => {
            // For env, suggest common env vars
            let common_vars = vec![
                ("CI", "CI environment"),
                ("GITHUB_ACTIONS", "GitHub Actions"),
                ("USER", "Current user"),
                ("HOME", "Home directory"),
                ("PATH", "PATH variable"),
            ];
            
            for (name, detail) in common_vars {
                completions.push(CompletionItem {
                    label: name.to_string(),
                    kind: Some(CompletionItemKind::VARIABLE),
                    detail: Some(detail.to_string()),
                    insert_text: Some(format!("{}}}",name)),
                    ..Default::default()
                });
            }
        }
        _ => {
            // Unknown prefix - no suggestions
        }
    }
    
    completions
}
